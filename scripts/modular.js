#target photoshop/* @@@BUILDINFO@@@ Modular.jsx 0.0.1 *//* global activeDocument, ElementPlacement, app *//** Требования: слои для обработки должны называться десятичной цифрой без букв */var PSD_FOLDER_PATH = '~/Documents/Photoshop TZ/';var OUT_SUBFOLDER = '_/';var JPG_QUALITY = 10;// разница между `y` нижней границы модуля и `y` верхней границы черного прямоугольникаvar BOTTOM_RECT_UP = 20;// разница между `y` нижней границы модуля и `y` нижней границы черного прямоугольникаvar BOTTOM_RECT_BOTTOM = 30;// разница между `x` правой границы модуля и `x` правой границы черного прямоугольникаvar BOTTOM_RECT_RIGHT = 20;// разница между `x` правой границы модуля и `x` левой границы черного прямоугольникаvar RIGHT_RECT_LEFT = 20;// разница между `x` правой границы модуля и `x` правой границы черного прямоугольникаvar RIGHT_RECT_RIGHT = 20;// разница между `y` нижней границы модуля и `y` нижней границы черного прямоугольникаvar RIGHT_RECT_BOTTOM = 40;// разница между `y` верхней границы модуля и `y` верхней границы черного прямоугольникаvar RIGHT_RECT_UP = 10;// величина обрезки угла слояvar LAYER_CORNER_CROP = 10;var ORIENTATION = {  UP: 0,  DOWN: 1,  LEFT: 2,  RIGHT: 3};openFilesInDir(PSD_FOLDER_PATH);processAllDocuments();/** * Обрабатывает целевой слой: добавляет тень, обрезает углы. * @param {ArtLayer} layer * @returns {ArtLayers[]} созданные в процессе слои */function processModularLayer(layer, fon) {  /*   (x, y) верхнего левого угла   (x, y) нижнего правого угла   */  var bounds = layer.boundsNoEffects;  /*   Создаем новый слой и помещаем его под слой, который обрабатываем   */  var rectLayer = activeDocument.artLayers.add();  rectLayer.name = layer.name + '_' + 'shadow';  rectLayer.move(fon, ElementPlacement.PLACEBEFORE);  activeDocument.activeLayer = rectLayer;  /*   Выделяем область для нижнего черного прямоугольника   */  var left = bounds[0].value;  var top = bounds[1].value;  var right = bounds[2].value;  var bottom = bounds[3].value;  var bottomRectCoords = [    [left, bottom - BOTTOM_RECT_UP],    [right - RIGHT_RECT_LEFT, bottom - BOTTOM_RECT_UP],    [right - RIGHT_RECT_LEFT, bottom + BOTTOM_RECT_BOTTOM],    [left, bottom + BOTTOM_RECT_BOTTOM]  ];  createRectAndFillWithBlack(rectLayer, bottomRectCoords);  var rightRectCoords = [    [right - RIGHT_RECT_LEFT, top - RIGHT_RECT_UP],    [right + RIGHT_RECT_RIGHT, top - RIGHT_RECT_UP],    [right + RIGHT_RECT_RIGHT, bottom + BOTTOM_RECT_BOTTOM],    [right - RIGHT_RECT_LEFT, bottom + BOTTOM_RECT_BOTTOM]  ];  createRectAndFillWithBlack(rectLayer, rightRectCoords);    cropShadowCorners(rectLayer, bottomRectCoords, rightRectCoords);  applyGaussianBlur(rectLayer);  cropLayerCorners(layer);  exposureLayerRect(layer, rightRectCoords);    return [rectLayer];}function exposureLayerRect(layer, coords) {  activeDocument.activeLayer = layer;  activeDocument.selection.select(coords);  // копия слоя с выделением  var idCpTL = charIDToTypeID("CpTL");  executeAction(idCpTL, undefined, DialogModes.NO);  exposureSelection();}function applyGaussianBlur(layer) {  activeDocument.activeLayer = layer;  activeDocument.selection.selectAll();  activeDocument.activeLayer.applyGaussianBlur(9);}function cropLayerCorners(layer) {  /*   (x, y) верхнего левого угла   (x, y) нижнего правого угла   */  var bounds = layer.boundsNoEffects;  var left = bounds[0].value;  var top = bounds[1].value;  var right = bounds[2].value;  var bottom = bounds[3].value;  activeDocument.activeLayer = layer;  cropCorner([right, top], [right - LAYER_CORNER_CROP, top], ORIENTATION.DOWN);  cropCorner([right, bottom], [right - LAYER_CORNER_CROP, bottom], ORIENTATION.UP);}/** Обрезает углы у тени. */function cropShadowCorners(layer, bottomRectCoords, rightRectCoords) {  activeDocument.activeLayer = layer;  var left = bottomRectCoords[0][0];  var up = bottomRectCoords[0][1];  var right = bottomRectCoords[2][0];  var bottom = bottomRectCoords[2][1];  // нижний левый угол  cropCorner([left, bottom], [left + (bottom - up) * 2 / 3, bottom], ORIENTATION.UP);  left = rightRectCoords[0][0];  up = rightRectCoords[0][1];  right = rightRectCoords[2][0];  bottom = rightRectCoords[2][1];  // нижний левый угол  cropCorner([right, up], [right, up + (right - left)], ORIENTATION.LEFT);}/** Выдержка для выделения. */function exposureSelection() {  var desc4 = new ActionDescriptor();  desc4.putEnumerated(    stringIDToTypeID("presetKind"),    stringIDToTypeID("presetKindType"),    stringIDToTypeID("presetKindCustom")  );  desc4.putDouble(charIDToTypeID("Exps"), -2.000000);  desc4.putDouble(charIDToTypeID("Ofst"), 0.000000);  desc4.putDouble(stringIDToTypeID("gammaCorrection"), 1.000000);  executeAction(charIDToTypeID("Exps"), desc4, DialogModes.NO);}/** Заливает область выделения черным. */function createRectAndFillWithBlack(layer, coords) {  activeDocument.activeLayer = layer;  activeDocument.selection.select(coords);  app.foregroundColor.rgb.hexColor = 'ff0000';  app.foregroundColor.model = ColorModel.RGB;  activeDocument.selection.fill(app.foregroundColor, ColorBlendMode.COLOR, '50');}/**  Обрабатывает документ. */function processDocument(document) {  var layer;  var LAYER_NAME_RE = new RegExp('^\\d+$', 'ig');  var fon;  var layersToProcess = [];  for (var j = 0; j < document.artLayers.length; j++) {    layer = document.artLayers[j];    if (LAYER_NAME_RE.test(layer.name)) {      // обрабатываем слой с картинкой      layersToProcess.push(layer);    }    if (layer.name === 'fon') {      fon = layer;    }  }  for (var j = 0; j < layersToProcess.length; j++) {    layer = layersToProcess[j];    if (LAYER_NAME_RE.test(layer.name)) {      // обрабатываем слой с картинкой      processModularLayer(layer, fon);    }  }  // save and close  saveJPEG();}/** Обрабатывает все открытые документы. */function processAllDocuments() {  var doc;  for (var i = 0; i < app.documents.length; i++) {    doc = app.documents[i];    app.activeDocument = doc;    processDocument(doc);  }}function openFilesInDir(folderPath) {  // A hard coded path to a directory 'mac style'  var processFolder = Folder(folderPath);  // Use folder object get files function with mask 'a reg ex'  var fileList = processFolder.getFiles(/\.(psd)$/i);  for (var i = 0; i < fileList.length; i++) {    // Only process the returned file objects    // The filter 'should' have missed out any folder objects    if (fileList[i] instanceof File && fileList[i].hidden == false) {      // get a reference to the new document      open(fileList[i]);    }  }}function saveJPEG() {  var doc = app.activeDocument;  if (doc.bitsPerChannel != BitsPerChannelType.EIGHT) {    doc.bitsPerChannel = BitsPerChannelType.EIGHT;  }  var fileName = doc.name.replace(/\.[^.]+$/, '');  var file = new File(PSD_FOLDER_PATH + OUT_SUBFOLDER + fileName + '.jpg');  var jpgSaveOptions = new JPEGSaveOptions();  jpgSaveOptions.embedColorProfile = false;  jpgSaveOptions.formatOptions = FormatOptions.STANDARDBASELINE;  jpgSaveOptions.matte = MatteType.NONE;  jpgSaveOptions.quality = JPG_QUALITY;  activeDocument.saveAs(file, jpgSaveOptions, true, Extension.LOWERCASE);}// =====================================================================================================/** @param {[x,y][]]} points */function cropArea(points) {  _selectLasso();  _selectPoints(points);  _deleteArea();}function _deleteArea() {  var idDlt = charIDToTypeID( "Dlt " );  executeAction( idDlt, undefined, DialogModes.NO );}function _selectLasso() {  // Выбираем полигональное лассо  // =======================================================  var select = new ActionDescriptor();  var ref30 = new ActionReference();  var idpolySelTool = stringIDToTypeID( "polySelTool" );  ref30.putClass( idpolySelTool );  select.putReference(    charIDToTypeID( "null" ),    ref30 );  var iddontRecord = stringIDToTypeID( "dontRecord" );  select.putBoolean( iddontRecord, true );  var idforceNotify = stringIDToTypeID( "forceNotify" );  select.putBoolean( idforceNotify, true );  executeAction(    charIDToTypeID( "slct" ),    select, DialogModes.NO );}function _selectPoints(points) {  var mainAction = new ActionDescriptor();  var ref31 = new ActionReference();  var idChnl = charIDToTypeID( "Chnl" );  var idfsel = charIDToTypeID( "fsel" );  ref31.putProperty( idChnl, idfsel );  mainAction.putReference( charIDToTypeID( "null" ), ref31 );  var pointsDescripts = new ActionDescriptor();  var pointsList = new ActionList();  var pointD;  var currentPoint;  for (var i = 0; i < points.length; i++) {    pointD = new ActionDescriptor();    currentPoint = points[i];    pointD.putUnitDouble(charIDToTypeID("Hrzn"), charIDToTypeID("#Pxl"), currentPoint[0]);    pointD.putUnitDouble(charIDToTypeID("Vrtc"), charIDToTypeID("#Pxl"), currentPoint[1]);    pointsList.putObject(charIDToTypeID("Pnt "), pointD);  }  pointsDescripts.putList(charIDToTypeID("Pts "), pointsList);  mainAction.putObject(charIDToTypeID( "T   " ), charIDToTypeID( "Plgn" ), pointsDescripts);  mainAction.putBoolean(charIDToTypeID( "AntA" ), true);  executeAction(charIDToTypeID( "setd" ), mainAction, DialogModes.NO);}function cropCorner(cornerPoint, trianglePoint, orientation, angle) {  // дефолтный угол – 45 градусов  angle = angle || Math.PI / 4;  var isHorizontal = cornerPoint[1] === trianglePoint[1];  // катет рядом с углом  var cat = Math.abs(isHorizontal ? cornerPoint[0] - trianglePoint[0] : cornerPoint[1] - trianglePoint[1]);  var otherCat = Math.tan(angle) * cat;  var thirdPoint = [];  if (isHorizontal) {    thirdPoint[0] = cornerPoint[0];    thirdPoint[1] = cornerPoint[1] + (orientation === ORIENTATION.DOWN ? 1 : -1) * otherCat;  } else {    thirdPoint[1] = cornerPoint[1];    thirdPoint[0] = cornerPoint[0] + (orientation === ORIENTATION.RIGHT ? 1 : -1) * otherCat;  }  cropArea([    trianglePoint,    cornerPoint,    thirdPoint  ]);}